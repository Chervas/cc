import { Injectable, inject } from '@angular/core';
import { BehaviorSubject, Observable, throwError, of } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { catchError, map, switchMap } from 'rxjs/operators';

// üîó INTEGRACI√ìN CON FUSE AUTH
import { AuthService } from 'app/core/auth/auth.service';

// üîê DEFINICI√ìN CLARA DE ROLES CON SEGURIDAD
export enum UserRole {
    ADMIN = 'admin',
    PROPIETARIO = 'propietario',
    DOCTOR = 'doctor',
    PERSONAL_CLINICA = 'personaldeclinica',
    PACIENTE = 'paciente'
}

// üè• INTERFACE PARA CL√çNICA CON ROL
export interface ClinicaConRol {
    id_clinica: number;
    nombre_clinica: string;
    rol_clinica: UserRole;
    subrol_clinica?: string;
    grupoclinica?: {
        nombre_grupo: string;
    };
    // ‚úÖ COMPATIBILIDAD CON THIN COMPONENT
    grupoClinica?: {
        nombre_grupo: string;
    };
    // üîí CAMPOS DE SEGURIDAD
    permissions?: {
        canMapAssets: boolean;
        canManageSettings: boolean;
        canViewReports: boolean;
        isSystemAdmin: boolean;
    };
}

// üë§ INTERFACE PARA USUARIO CON ROLES Y SEGURIDAD
export interface UsuarioConRoles {
    id_usuario: number;
    roles: UserRole[];
    clinicas: ClinicaConRol[];
    isAdmin: boolean;
    // üîí CAMPOS DE SEGURIDAD JWT (integrados con Fuse)
    tokenExpiry?: Date;
    lastRoleValidation?: Date;
    sessionId?: string;
}

// üîç INTERFACE PARA VALIDACI√ìN DE ROLES
export interface RoleValidationResponse {
    valid: boolean;
    roles: UserRole[];
    clinicas: ClinicaConRol[];
    tokenExpiry: Date;
    message?: string;
}

@Injectable({
    providedIn: 'root'
})
export class RoleService {
    // üîó INTEGRACI√ìN CON FUSE AUTH
    private authService = inject(AuthService);
    private http = inject(HttpClient);

    // üîí ESTADO CENTRALIZADO CON SEGURIDAD
    private currentUserSubject = new BehaviorSubject<UsuarioConRoles | null>(null);
    private selectedRoleSubject = new BehaviorSubject<UserRole | null>(null);
    private availableRolesSubject = new BehaviorSubject<UserRole[]>([]);
    private roleValidationSubject = new BehaviorSubject<boolean>(false);

    // üîç OBSERVABLES P√öBLICOS - CORREGIDOS PARA COMPATIBILIDAD
    public currentUser$ = this.currentUserSubject.asObservable();
    public selectedRoles = this.selectedRoleSubject.asObservable();
    public selectedRole$ = this.selectedRoleSubject.asObservable(); // ‚úÖ AGREGADO PARA THIN COMPONENT
    public availableRoles$ = this.availableRolesSubject.asObservable();
    public isRoleValid$ = this.roleValidationSubject.asObservable();

    // ‚öôÔ∏è CONFIGURACI√ìN DE ADMINS (basada en documentaci√≥n antigua)
    private readonly ADMIN_USER_IDS = [1, 2, 5];

    // ‚è±Ô∏è CONFIGURACI√ìN DE SEGURIDAD
    private readonly ROLE_VALIDATION_INTERVAL = 5 * 60 * 1000; // 5 minutos
    private readonly MAX_ROLE_CACHE_TIME = 10 * 60 * 1000; // 10 minutos
    private validationTimer?: any;

    constructor() {
        this.initializeIntegration();
    }

    // üîó INICIALIZACI√ìN INTEGRADA CON FUSE - CORREGIDA SEG√öN DOCUMENTACI√ìN
    private initializeIntegration(): void {
        console.log('üîÑ Inicializando integraci√≥n con Fuse Auth...');
        
        // üîç SUSCRIBIRSE A CAMBIOS DE AUTENTICACI√ìN DE FUSE
        this.authService.getCurrentUser().subscribe(user => {
            console.log('üîó Usuario recibido de Fuse Auth:', user);
            
            if (user?.id_usuario) {
                console.log('üîó Usuario v√°lido detectado, ID:', user.id_usuario);
                // ‚úÖ INICIALIZAR INMEDIATAMENTE CON LOS DATOS DISPONIBLES
                this.initializeUserFromFuseData(user);
            } else {
                console.log('üîó No hay usuario autenticado en Fuse');
                this.clearUserSession();
            }
        });

        this.loadPersistedRole();
        this.startRoleValidationTimer();

        // üîÑ VALIDAR ROLES AL CAMBIAR DE PESTA√ëA/VENTANA
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                this.validateCurrentRoles();
            }
        });
    }

    // üîê INICIALIZACI√ìN DIRECTA DESDE DATOS DE FUSE - NUEVO M√âTODO
    private initializeUserFromFuseData(fuseUser: any): void {
        try {
            console.log('üîÑ Inicializando usuario desde datos de Fuse:', fuseUser);

            // üîí VALIDAR DATOS DE ENTRADA
            if (!fuseUser || !fuseUser.id_usuario) {
                console.error('üö® Datos de usuario de Fuse inv√°lidos');
                this.clearUserSession();
                return;
            }

            // üîÑ DETERMINAR ROLES BASADO EN ID (seg√∫n documentaci√≥n antigua)
            const isAdmin = this.ADMIN_USER_IDS.includes(fuseUser.id_usuario);
            let roles: UserRole[] = [];
            
            if (isAdmin) {
                roles = [UserRole.ADMIN];
                console.log('üîê Usuario identificado como ADMIN');
            } else {
                // Para usuarios no-admin, asignar rol por defecto y cargar desde backend
                roles = [UserRole.PACIENTE]; // Fallback temporal
                console.log('üîê Usuario no-admin, cargando roles desde backend...');
                this.loadUserRolesFromBackend(fuseUser.id_usuario);
            }

            const usuario: UsuarioConRoles = {
                id_usuario: fuseUser.id_usuario,
                roles: roles,
                clinicas: [], // Se cargar√°n despu√©s
                isAdmin: isAdmin,
                tokenExpiry: this.extractTokenExpiryFromFuse(),
                lastRoleValidation: new Date(),
                sessionId: this.generateSessionId()
            };

            // ‚úÖ ACTUALIZAR ESTADO INMEDIATAMENTE
            this.currentUserSubject.next(usuario);
            this.availableRolesSubject.next(roles);
            this.roleValidationSubject.next(true);

            // Seleccionar rol por defecto
            this.selectDefaultRole(roles);

            console.log('‚úÖ Usuario inicializado desde Fuse:', {
                id: usuario.id_usuario,
                roles: usuario.roles,
                isAdmin: usuario.isAdmin
            });

        } catch (error) {
            console.error('üö® Error inicializando usuario desde Fuse:', error);
            this.clearUserSession();
        }
    }

    // üîÑ CARGAR ROLES DESDE BACKEND - NUEVO M√âTODO
    private loadUserRolesFromBackend(userId: number): void {
        console.log('üîÑ Cargando roles desde backend para usuario:', userId);
        
        // Simular carga desde backend (implementar seg√∫n endpoints reales)
        // Basado en la documentaci√≥n: endpoint getClinicasByUser deber√≠a retornar roles
        this.http.get(`/api/user/${userId}/clinicas`).subscribe({
            next: (response: any) => {
                console.log('üìã Respuesta del backend:', response);
                
                if (response.clinicas && Array.isArray(response.clinicas)) {
                    const roles = this.extractRolesFromClinics(response.clinicas);
                    this.updateUserRoles(roles);
                    console.log('‚úÖ Roles cargados desde backend:', roles);
                } else {
                    console.warn('‚ö†Ô∏è No se encontraron cl√≠nicas en la respuesta del backend');
                }
            },
            error: (error) => {
                console.error('üö® Error cargando roles desde backend:', error);
                // Mantener roles por defecto
            }
        });
    }

    /**
     * üîÑ Inicializa el usuario con validaci√≥n de seguridad JWT integrada con Fuse
     * M√âTODO MANTENIDO PARA COMPATIBILIDAD
     */
    initializeUser(userData: any): void {
        console.log('üîÑ initializeUser llamado (m√©todo legacy):', userData);
        // Redirigir al nuevo m√©todo
        this.initializeUserFromFuseData(userData);
    }

    /**
     * üîÑ Selecciona un rol espec√≠fico con validaci√≥n de seguridad
     */
    selectRole(role: UserRole): void {
        const currentUser = this.currentUserSubject.value;
        if (!currentUser) {
            console.error('üö® No hay usuario para seleccionar rol');
            return;
        }

        const normalizedRole = this.normalizeRole(role);
        if (!this.isValidRole(normalizedRole) || !currentUser.roles.includes(normalizedRole)) {
            console.error('üö® Rol no v√°lido o no disponible:', role);
            return;
        }

        this.selectedRoleSubject.next(normalizedRole);
        localStorage.setItem('selectedRole', normalizedRole);
        
        console.log('üîÑ Rol seleccionado:', normalizedRole);
    }

    /**
     * üè• Obtiene cl√≠nicas filtradas por el rol actual con seguridad
     */
    getClinicasByCurrentRole(): ClinicaConRol[] {
        const currentUser = this.currentUserSubject.value;
        const currentRole = this.selectedRoleSubject.value;

        if (!currentUser || !currentRole) {
            console.log('üö® Usuario o rol no v√°lido para filtrar cl√≠nicas');
            return [];
        }

        // Admin puede ver todas las cl√≠nicas
        if (currentRole === UserRole.ADMIN) {
            console.log('üîê Cargando cl√≠nicas para administrador');
            return currentUser.clinicas;
        }

        // Filtrar cl√≠nicas por rol espec√≠fico
        const filteredClinics = currentUser.clinicas.filter(clinica => 
            clinica.rol_clinica === currentRole
        );

        if (filteredClinics.length === 0) {
            console.log('üîê No hay cl√≠nicas para filtrar');
        }

        return filteredClinics;
    }

    /**
     * üîç Verifica si el usuario tiene un rol espec√≠fico - CORREGIDO
     */
    hasRole(role: UserRole): boolean {
        const currentUser = this.currentUserSubject.value;
        if (!currentUser) {
            console.log('üîê hasRole(' + role + '): false (no user)');
            return false;
        }

        const normalizedRole = this.normalizeRole(role);
        const hasRole = currentUser.roles.includes(normalizedRole);
        console.log('üîê hasRole(' + role + '): ' + hasRole + ' [usuario v√°lido]');
        return hasRole;
    }

    /**
     * üîí Verifica si el usuario es administrador
     */
    isAdmin(): boolean {
        const currentUser = this.currentUserSubject.value;
        const isAdmin = currentUser?.isAdmin || false;
        console.log('üîê isAdmin(): ' + isAdmin);
        return isAdmin;
    }

    /**
     * üìã Obtiene el rol actual seleccionado
     */
    getCurrentRole(): UserRole | null {
        const role = this.selectedRoleSubject.value;
        console.log('üîê getCurrentRole(): ' + role);
        return role;
    }

    /**
     * ‚úÖ Valida los roles actuales del usuario
     */
    validateCurrentRoles(): Observable<RoleValidationResponse> {
        const currentUser = this.currentUserSubject.value;
        if (!currentUser) {
            return throwError(() => new Error('No hay usuario autenticado'));
        }

        // Simular validaci√≥n exitosa por ahora
        const response: RoleValidationResponse = {
            valid: true,
            roles: currentUser.roles,
            clinicas: currentUser.clinicas,
            tokenExpiry: currentUser.tokenExpiry || new Date(Date.now() + 3600000),
            message: 'Roles validados correctamente'
        };

        this.roleValidationSubject.next(response.valid);
        return of(response);
    }

    /**
     * üßπ Limpia la sesi√≥n del usuario
     */
    clearUserSession(): void {
        console.log('üßπ Limpiando sesi√≥n de usuario');
        this.currentUserSubject.next(null);
        this.selectedRoleSubject.next(null);
        this.availableRolesSubject.next([]);
        this.roleValidationSubject.next(false);
        localStorage.removeItem('selectedRole');
        
        if (this.validationTimer) {
            clearInterval(this.validationTimer);
        }
    }

    // üõ†Ô∏è M√âTODOS AUXILIARES PRIVADOS

    /**
     * üîç Extrae roles de las cl√≠nicas del usuario
     */
    private extractRolesFromClinics(clinicas: any[]): UserRole[] {
        if (!Array.isArray(clinicas)) return [];
        
        const roles = new Set<UserRole>();
        
        clinicas.forEach(clinica => {
            if (clinica.rol_clinica) {
                const normalizedRole = this.normalizeRole(clinica.rol_clinica);
                if (this.isValidRole(normalizedRole)) {
                    roles.add(normalizedRole);
                }
            }
        });
        
        return Array.from(roles);
    }

    /**
     * üßπ Sanitiza las cl√≠nicas para seguridad
     */
    private sanitizeClinicas(clinicas: any[]): ClinicaConRol[] {
        if (!Array.isArray(clinicas)) return [];
        
        return clinicas.map(clinica => ({
            id_clinica: clinica.id_clinica || 0,
            nombre_clinica: clinica.nombre_clinica || 'Sin nombre',
            rol_clinica: this.normalizeRole(clinica.rol_clinica),
            subrol_clinica: clinica.subrol_clinica,
            grupoclinica: clinica.grupoclinica,
            // ‚úÖ COMPATIBILIDAD CON THIN COMPONENT
            grupoClinica: clinica.grupoclinica || clinica.grupoClinica,
            permissions: {
                canMapAssets: clinica.permissions?.canMapAssets || false,
                canManageSettings: clinica.permissions?.canManageSettings || false,
                canViewReports: clinica.permissions?.canViewReports || false,
                isSystemAdmin: clinica.permissions?.isSystemAdmin || false
            }
        })).filter(clinica => clinica.id_clinica > 0);
    }

    /**
     * ‚úÖ Valida que los roles extra√≠dos sean v√°lidos
     */
    private validateExtractedRoles(roles: UserRole[]): boolean {
        if (!Array.isArray(roles) || roles.length === 0) return false;
        return roles.every(role => this.isValidRole(role));
    }

    /**
     * üîß Normaliza un rol a formato est√°ndar - CORREGIDO PARA EVITAR toUpperCase() ERROR
     */
    private normalizeRole(role: any): UserRole {
        // üö® VALIDACI√ìN CR√çTICA: Prevenir error de toUpperCase() en undefined/null
        if (role === null || role === undefined) {
            console.warn('üö® Rol null/undefined detectado, usando PACIENTE como fallback');
            return UserRole.PACIENTE;
        }
        
        // Convertir a string de forma segura
        let roleStr: string;
        try {
            roleStr = String(role).toLowerCase().trim();
        } catch (error) {
            console.error('üö® Error convirtiendo rol a string:', error, 'rol:', role);
            return UserRole.PACIENTE;
        }
        
        // Validar que no est√© vac√≠o despu√©s del trim
        if (!roleStr || roleStr.length === 0) {
            console.warn('üö® Rol vac√≠o detectado, usando PACIENTE como fallback');
            return UserRole.PACIENTE;
        }
        
        switch (roleStr) {
            case 'admin':
            case 'administrador':
                return UserRole.ADMIN;
            case 'propietario':
            case 'owner':
                return UserRole.PROPIETARIO;
            case 'doctor':
            case 'medico':
                return UserRole.DOCTOR;
            case 'personaldeclinica':
            case 'personal_clinica':
            case 'staff':
                return UserRole.PERSONAL_CLINICA;
            case 'paciente':
            case 'patient':
                return UserRole.PACIENTE;
            default:
                console.warn('üö® Rol desconocido:', roleStr, 'usando PACIENTE como fallback');
                return UserRole.PACIENTE;
        }
    }

    /**
     * ‚úÖ Verifica si un rol es v√°lido
     */
    private isValidRole(role: UserRole): boolean {
        return Object.values(UserRole).includes(role);
    }

    /**
     * ‚è∞ Extrae la expiraci√≥n del token desde Fuse
     */
    private extractTokenExpiryFromFuse(): Date | null {
        try {
            // Intentar obtener desde el AuthService de Fuse
            const token = localStorage.getItem('accessToken');
            if (!token) return null;
            
            const payload = JSON.parse(atob(token.split('.')[1]));
            return payload.exp ? new Date(payload.exp * 1000) : null;
        } catch {
            return null;
        }
    }

    /**
     * üÜî Genera un ID de sesi√≥n √∫nico
     */
    private generateSessionId(): string {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    /**
     * üéØ Selecciona el rol por defecto
     */
    private selectDefaultRole(availableRoles: UserRole[]): void {
        if (availableRoles.length === 0) return;
        
        // Prioridad: Admin > Propietario > Doctor > Personal > Paciente
        const priority = [UserRole.ADMIN, UserRole.PROPIETARIO, UserRole.DOCTOR, UserRole.PERSONAL_CLINICA, UserRole.PACIENTE];
        
        for (const role of priority) {
            if (availableRoles.includes(role)) {
                this.selectRole(role);
                return;
            }
        }
        
        // Fallback al primer rol disponible
        this.selectRole(availableRoles[0]);
    }

    /**
     * üíæ Carga el rol persistido del localStorage
     */
    private loadPersistedRole(): void {
        const savedRole = localStorage.getItem('selectedRole') as UserRole;
        if (savedRole && this.isValidRole(savedRole)) {
            this.selectedRoleSubject.next(savedRole);
        }
    }

    /**
     * ‚è±Ô∏è Inicia el timer de validaci√≥n de roles
     */
    private startRoleValidationTimer(): void {
        this.validationTimer = setInterval(() => {
            this.validateCurrentRoles().subscribe({
                next: (response) => {
                    if (!response.valid) {
                        console.warn('‚ö†Ô∏è Validaci√≥n de roles fall√≥, limpiando sesi√≥n');
                        this.clearUserSession();
                    }
                },
                error: (error) => {
                    console.error('üö® Error en validaci√≥n autom√°tica de roles:', error);
                }
            });
        }, this.ROLE_VALIDATION_INTERVAL);
    }

    /**
     * üîÑ Actualiza los roles del usuario
     */
    private updateUserRoles(newRoles: UserRole[]): void {
        const currentUser = this.currentUserSubject.value;
        if (!currentUser) return;

        const updatedUser: UsuarioConRoles = {
            ...currentUser,
            roles: newRoles,
            lastRoleValidation: new Date()
        };

        this.currentUserSubject.next(updatedUser);
        this.availableRolesSubject.next(newRoles);
        
        console.log('üîÑ Roles actualizados:', newRoles);
    }

    ngOnDestroy(): void {
        if (this.validationTimer) {
            clearInterval(this.validationTimer);
        }
    }
}

